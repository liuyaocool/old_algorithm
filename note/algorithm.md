# 数据结构

1. 百度 Data Structure
2. geeksforgeeks.org
3. visualgo.net/zh

存储数据的不同方式 -- 数组,链表

- HashMap： 
  - 数组+链表(1.7) 
  - 数组+链表+红黑树(1.8)
    - 链表>=7 使用红黑树 泊松分布
- LinkedHashMap： 链表
- TreeMap： 红黑树

## ArrayList 动态扩容

## 连续数组

## 链表

## 树

## 二叉树

## AVL树

严格平衡二叉树

## 红黑树

## B-Tree

## B+Tree

## Hash表   (k,v)表

HashMap  增删改查 都是O(1) 但常数时间是比较大的

1. 按值传递：
   - String，Integer等包装类， 。。。
   - k，v都为String， 则hash表这条数据为 两个String相加的字节数
2. 按引用传递：非原生类型，如 new Person()， k为内存地址
   - k，v都为引用， 则hash表这条数据为 8+8=16字节

## 有序表

TreeMap  增删改查 都是logN

要求 key一定是可以比较的

1. firstKey   lastKey
2. floorKey(key)    --<=key的最近的key
3. ceilingKey(key)    -->=key的最近的key

## 跳表

ConcurrentSkipListMap

![](img\skip-table.png)

多加了索引链表

# 算法

- 同一问题的不同解决方法
- 算法往往是针对特定数据结构的
- 测算算法优劣
  - 时间
  - 空间
- 稳定性 如：数组中两个数相等，排序完成后，这些相等数的相对位置可能发生变化

## 常见排序算法

```
       名称                 平均O()      最坏O()        最好O()     空间复杂度    稳定性
    选择排序（Selection）      n^2         n^2           n^2            1         不稳
    冒泡排序（Bubble）         n^2         n^2            n             1         稳
    插入排序（Insertion）      n^2         n^2            n             1         稳
    堆排序（heap）         n*log_2`n    n*log_2`n     n*log_2`n         1         不稳
    希尔排序（Shell）        n^1.3         n^2            n             1         不稳
    归并排序（Merge）      n*log_2`n    n*log_2`n     n*log_2`n         n         稳
    快速排序（Quick）      n*log_2`n       n^2        n*log_2`n     n*log_2`n     不稳
    桶排序（Bucket）          n+k          n^2           n             n+k        稳
    计数排序（Counting）      n+k          n+k          n+k            n+k        稳
    基数排序（Radix）         n*k          n*k          n*k            n+k        稳
```

1. 选择排序：
   1. 0~n-1 最小放到0
   2. 1~n-1 最小放到1
   3. 。。。
2. 冒泡排序：
   1. 0~1、1~2、2~3、。。n-2~n-1 大的后放
   2. 0~1、1~2、2~3、。。n-3~n-2 大的后放
   3. 。。。
3. 插入排序：有点像摸牌，前边已经排好了，新牌从后往前排插入
   1. 0~1 ：1位置与前边比较，前一个比自己大 往前换，直到前边<=自己 停止
   2. 0~2 ：2位置与前边比较，。。。
   3. 0~3 ：3位置与前边比较，。。。
   4. ...
4. 希尔排序： 间隔插入排序
   -  间隔序列Knuth： h=1 h=3*h+1=4 h=3*4+1=13 ...
   - 例如：间隔取4， 则取 i%4 == 0 的为一组排序（仍在原数组，只不过下标间隔为4），排完之后在以间隔为2的排序，最终以间隔为1排序
     - 即 先将 0，4，8，12，。。。位置进行插入排序
     - 再将 0，2，4，6，8，。。。位置进行插入排序
     - 最后将 0，1，2，3，4，。。。位置进行插入排序
5. 归并排序：两个子数组（对半劈）排好顺序，然后合并到新数组，递归子数组
   - 过程：3个指针 两个子数组指针 一个新数组指针，2个子数组指针后移比较 放到新数组 新数组指针后移
6. TIM SORT
   - java内部 对象排序（要求稳定）使用的是改进的归并排序 叫TIM SORT
   - 多路归并 先分多块 然后两两归并 再两两归并 。。。
7. 快速排序：单轴快排
   - 过程：找到一个轴，小于轴的放到左边大于轴的放到右边
8. 双轴快排：Arrays.sort(基础数据类型)

# 常识
## 固定时间

执行时间与数据无关

常数操作: int a + int b, a b都是32位 不管数多大 都是同样的操作，常见常数操作：

```
+ - * / >> >>> << | & ^ 赋值 比较 自增 自减 数组寻址(arr[10000]) ...
## 数组(arr[])寻址: 内存中取 200万位置 与800万位置 是一样的时间
```

## 非固定时间

执行时间与数据有关，如 LinkedList中 查找200万位置 与800万位置

# 评估算法的优劣

1. 时间复杂度 流程决定，排名：

   ```
   O(1) < O(logN=log 2 n) < O(N) < O(N*logN) < O(N^2) < O(N^3) < .. < O(N^k) < O(2^n) < O(3^n) < .. < O(k^n) < O(N!)
   ```

2. 额外空间复杂度 流程决定

3. 常数项时间(不重要) 实现细节决定

   - 例如：^ < + <<< /

## 时间复杂度O(?)

​	常数操作O(1)的数量可以归纳为一个n(需要计算的n个数)的m次方的m阶方程式，例如a*n^m + b*n^(m-1) + ... + c*n + d，则此算法的时间复杂度为O(n^m)，读big O n的m次方。

​	即 将过程拆分 确保拆分后的每一个操作都是**时间固定**的操作(例如常数操作)，并可用f(n）函数表示,其中**最大的指数级**就是时间复杂度

**如: 选择排序,n个数  O(N^2)**
    // 常数操作:交换 比较, 时间复杂度为O(1);
    // n-1次比较, 比较总共的复杂度为(n-1)*O(1)
    第1次循环 0~n-1 比较n-1次 与0位置交换 复杂度=(n-1)*O(1)+O(1)
    第2次循环 1~n-1 比较n-2次 与0位置交换 复杂度=(n-2)*O(1)+O(1)
    第3次循环 2~n-1 比较n-3次 与0位置交换 复杂度=(n-3)*O(1)+O(1)
    ...
    第n-2次循环 n-3~n-1 比较2次 与0位置交换 复杂度=2*O(1)+O(1)
    第n-1次循环 n-2~n-1 比较1次 与0位置交换 复杂度=1*O(1)+O(1)
    ||
    总共进行了f(n)=(n-1)+(n-2)+...+2+1次比较和n-1次交换,得出常数
    化简 f(n)=[(n-1)+1]*(n-1)/2=0.5*n^2+0.5*n
    加上交换n-1 的o(n) = 0.5n^2 + 1.5*n -1
    取最大指数 n^2 得出时间复杂度为O(n^2)

**<u>如果性能随数据状况变化，则取时间复杂度最差状况的值</u>**
**例如 插入排序 a = [1,2,3,4,5,6,7]；b = [7,6,5,4,3,2,1] 取b的时间复杂度**
    b第1次循环 2位置排序插入0~0位置 0~0只有一个数 有序             → [6,7,5,4,3,2,1]
    b第2次循环 3位置排序插入0~1位置 此时0~1位置经过上一次处理已经有序 → [5,6,7,4,3,2,1]
    b第3次循环 4位置排序插入0~2位置 此时0~2位置经过上一次处理已经有序 → [4,5,6,7,3,2,1]
    ...
    直到 → [1,2,3,4,5,6,7]

**二分法时间复杂度:**  log 2 n    --n/2/2/2/2...

## 额外空间复杂度
除了数据的空间 和 算法需要返回的空间O(1), 算法过程中产生的其他空间叫额外空间固定个数的额外空间 = O(1); 其他 >= O(N)

**如**
给定arr[n] 要求算sum
    则int sum += arr[i]
    空间复杂度为O(1)
给定arr[n] 要求统计每个数出现的次数
    假设使用了map保存每个数的个数,按最差的每个数只出现一次算
    空间复杂读为O(N)
给定arr[n] 要求拷贝数据
    arr[n] ans
    空间复杂读为O(1)

# 注意

1. 注意 + * 操作的时候 结果溢出问题





# 学习方法

1. 对着镜子给自己讲
2. 给小白讲明白
3. 手动实现
4. **每一道题都有核心的两三句话，找个小本记下来**
5. 在纸上写20道题

题大怎么聊：比如 f() g() s() 三个黑盒，先聊f g s的调度，再问面试官 你让我实现哪个黑盒

# 笔记

https://shimowendang.com/docs/68cd6h3TwygPwx8W/read

# 学习规划

1. 新手班 -> 体系班1~40
2. 体系班41~47，难度较大，为低频题，但为知识点全面的补充
3. 图快：进阶班 49~78，特别高频
4. 此时可以去面试了
5. 进阶班17~48，经典面试题，跟大厂直播可以不看
6. 大厂刷题班 找新题看

ACM比赛

# 进度

- 新手班 扫盲
  - 04 00:39:00
- 基础班：升级到体系班
  - 基础
  - 低+中
- 进阶班：升级到体系班 和大厂刷题班
  - 基础 高级（前16）
  - 题（往年经典、高级）
- 体系班：03 01:16:30
  - 基础班
  - 进阶班 基础高
  - 题
  - 若干 升级版基础
- 大厂刷题班
  - 进阶班 题
  - 新题